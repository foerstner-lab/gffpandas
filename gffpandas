import argparse
import logging as lg

import argcomplete

from gffpandaslib.collapser import Collapser
from gffpandaslib.connector import Connector
from gffpandaslib.exporter import Exporter
from gffpandaslib.filter import Filter
from gffpandaslib.overlap_fetcher import OverlapFetcher


def main():
    # Entry point
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="commands", dest='command')
    # ___________________________________________________________________
    show_version_parser = subparsers.add_parser("version", help="Show version")
    show_version_parser.set_defaults(func=show_version)
    # ___________________________________________________________________
    exporter_parser = subparsers.add_parser("export",
                                            help="Export GFF3 file to various formats")
    exporter_parser.set_defaults(func=export_to_table)
    exporter_parser.add_argument("--input_gff", "-i", required=True, type=str,
                                 help="URL/file path to gff file or compressed gff")
    exporter_parser.add_argument("--output_file", "-o", required=True, type=str,
                                 help="Output file path and name including extension")
    exporter_parser.add_argument("--export_type", "-t", required=True, choices=["csv", "tsv", "xlsx", "md", "gff"],
                                 help="Output type of the export")
    exporter_parser.add_argument("--drop_columns", "-d", required=False, type=str, nargs="+",
                                 help="Mention a space separated column names to remove (lower case only)")
    exporter_parser.add_argument("--expand_attributes", "-e", action='store_true', default=False,
                                 help="Expand attributes to multiple columns")
    # ___________________________________________________________________
    overlap_fetcher_parser = subparsers.add_parser("fetch_overlap",
                                                   help="Fetches overlapping annotations from 2 sets "
                                                        "and adds it to the attributes")
    overlap_fetcher_parser.set_defaults(func=fetch_overlap)
    overlap_fetcher_parser.add_argument("--input_gff_a", "-i_a", required=True, type=str,
                                        help="URL/file path to gff file or compressed gff")
    overlap_fetcher_parser.add_argument("--input_gff_b", "-i_b", required=True, type=str,
                                        help="URL/file path to gff file or compressed gff")
    overlap_fetcher_parser.add_argument("--output_file", "-o", required=True, type=str,
                                        help="Output file path and name including extension")
    overlap_fetcher_parser.add_argument("--prefix", "-p", required=True, type=str,
                                        help="Any marking prefix string")
    overlap_fetcher_parser.add_argument("--allow_different_strands", "-a", default=False, action='store_true',
                                        help="All different strand overlap")
    # ___________________________________________________________________
    filter_parser = subparsers.add_parser("filter",
                                          help="Export GFF3 file to various formats")
    filter_parser.set_defaults(func=filter_annotations)
    filter_parser.add_argument("--input_gff", "-i", required=True, type=str,
                               help="URL/file path to gff file or compressed gff")
    filter_parser.add_argument("--output_file", "-o", required=True, type=str,
                               help="Output file path and name including extension")
    filter_parser.add_argument("--by", "-b", required=True, choices=["length", "type"],
                               help="Type of filtering required")
    filter_parser.add_argument("--min_len", "-n", required=False, type=int,
                               help="Minimum length required (> 0) for filtering by length")
    filter_parser.add_argument("--max_len", "-x", required=False, type=int,
                               help="Maximum length required (> 0) for filtering by length")
    filter_parser.add_argument("--annotation_type", "-t", required=False, type=str, nargs="+",
                               help="Annotation type required for filtering by type (space separated values)")
    # ___________________________________________________________________

    collapse_parser = subparsers.add_parser("collapse",
                                            help="Export GFF3 file to various formats")
    collapse_parser.set_defaults(func=collapse)
    collapse_parser.add_argument("--input_gffs", "-i", required=True, type=str, nargs="+",
                                 help="URL/file path to gff files or compressed gff,"
                                      "multiple GFF files will be combined as one GFF file")
    collapse_parser.add_argument("--output_file", "-o", required=True, type=str,
                                 help="Output file path and name including extension")
    collapse_parser.add_argument("--distance", "-x", required=False, type=int,
                                 help="Distance to merge overlaps (>= -1)")
    collapse_parser.add_argument("--annotate", "-a", type=str, choices=["all", "overlap", "no_overlap"],
                                 help="Choose output option, either to output only overlapped annotations, "
                                      "or only non-overlapped, or all", default="all")
    collapse_parser.add_argument("--annotation_types", "-t", type=str, nargs="+", default=None,
                                 help="Annotation type required for filtering by type (space separated values)")
    collapse_parser.add_argument("--rename_type", "-r", type=str, default=None,
                                 help="Rename the type column")
    collapse_parser.add_argument("--collapse_all_types", "-c", action='store_true',
                                 help="If used, will cause the program to merge overlapping annotations"
                                      " even if they are different in type")

    # ___________________________________________________________________
    connect_parser = subparsers.add_parser("connect",
                                           help="Fetches overlapping annotations from 2 sets and adds it to the attributes")
    connect_parser.set_defaults(func=connect_annotations)
    connect_parser.add_argument("--input_gff_a", "-i_a", required=True, type=str,
                                help="URL/file path to gff file or compressed gff")
    connect_parser.add_argument("--input_gff_b", "-i_b", required=True, type=str,
                                help="URL/file path to gff file or compressed gff")
    connect_parser.add_argument("--output_file", "-o", required=True, type=str,
                                help="Output file path and name including extension")
    connect_parser.add_argument("--min_len", "-n", required=True, type=int,
                                help="Maximum allowed length")
    connect_parser.add_argument("--max_len", "-x", required=True, type=int,
                                help="Maximum allowed length")
    connect_parser.add_argument("--new_type", "-t", required=False, type=str, default=None,
                                help="Give a name for the new sequences type")

    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    # Handling inconsistent argument passes
    if args.command == "export":
        if args.export_type == 'gff' and (args.expand_attributes is True or args.drop_columns is not None):
            parser.error("Arguments error: --export_type 'gff' cannot be used with"
                         "arguments --expand_attributes or --drop_columns")
    elif args.command == "filter":
        if args.by == 'length':
            if args.min_len is None or args.max_len is None:
                parser.error("Arguments error: filter by length requires arguments --min_len and --max_len")
        elif args.by == 'type':
            if args.annotation_type is None:
                parser.error("Arguments error: filter by type requires argument --annotation_type")
        else:
            exit(1)
    else:
        pass
    # passing argument to functions
    if "func" in dir(args):
        args.func(args)
    else:
        parser.print_help()


def show_version(args):
    """
    Version
    """
    # TODO
    pass


def export_to_table(args):
    if args.export_type == "gff":
        Exporter(args.input_gff).export_to_gff(output_file=args.output_file)
    else:
        Exporter(args.input_gff).export_to_table(to=args.export_type, output_file=args.output_file,
                                                 expand_attributes=True, drop_columns=args.drop_columns)


def fetch_overlap(args):
    OverlapFetcher(args.input_gff_a, args.input_gff_b, args.prefix, args.output_file) \
        .fetch_overlaps(allow_different_strands=args.allow_different_strands)


def filter_annotations(args):
    if args.by == "length":
        Filter(args.input_gff, args.output_file).filter_by_length(args.min_len, args.max_len)
    elif args.by == "type":
        Filter(args.input_gff, args.output_file).filter_by_type(args.type)
    else:
        lg.error(" Unrecognized filtering option")


def connect_annotations(args):
    Connector(args.input_gff_a, args.input_gff_b, args.output_file) \
        .connect_annotation(args.min_len, args.max_len, args.new_type)


def collapse(args):
    Collapser(args.input_gffs, args.annotation_types, args.output_file) \
        .collapse(args.collapse_all_types, args.distance, args.annotate, args.rename_type)


main()
