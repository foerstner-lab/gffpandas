import argparse
import logging as lg

import argcomplete

from gffpandaslib.annotation_filter import AnnotationFilter as af
from gffpandaslib.annotation_overlap_fetcher import AnnotationOverlapFetcher as aof
from gffpandaslib.gff3_exporter import Gff3Exporter


def main():
    # Entry point
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help="commands", dest='command')
    # ___________________________________________________________________
    show_version_parser = subparsers.add_parser("version", help="Show version")
    show_version_parser.set_defaults(func=show_version)
    # ___________________________________________________________________
    exporter_parser = subparsers.add_parser("export",
                                            help="Export GFF3 file to various formats")
    exporter_parser.set_defaults(func=export_to_table)
    exporter_parser.add_argument("--input_gff", "-i", required=True, type=str,
                                 help="URL/file path to gff file or compressed gff")
    exporter_parser.add_argument("--output_file", "-o", required=True, type=str,
                                 help="Output file path and name including extension")
    exporter_parser.add_argument("--export_type", "-t", required=True, choices=["csv", "tsv", "xlsx", "md", "gff"],
                                 help="Output type of the export")
    exporter_parser.add_argument("--drop_columns", "-d", required=False, type=str, nargs="+",
                                 help="Mention a space separated column names to remove (lower case only)")
    exporter_parser.add_argument("--expand_attributes", "-e", action='store_true', default=False,
                                 help="Expand attributes to multiple columns")

    # ___________________________________________________________________
    aof_parser = subparsers.add_parser("fetch_overlap",
                                       help="Fetches overlapping annotations from 2 sets and adds it to the attributes")
    aof_parser.set_defaults(func=fetch_overlap)
    aof_parser.add_argument("--input_gff_a", "-i_a", required=True, type=str,
                            help="URL/file path to gff file or compressed gff")
    aof_parser.add_argument("--input_gff_b", "-i_b", required=True, type=str,
                            help="URL/file path to gff file or compressed gff")
    aof_parser.add_argument("--output_file", "-o", required=True, type=str,
                            help="Output file path and name including extension")
    aof_parser.add_argument("--prefix", "-t", required=True, type=str,
                            help="Any marking prefix string")
    aof_parser.add_argument("--allow_different_strands", "-a", default=False, action='store_true',
                            help="All different strand overlap")
    # ___________________________________________________________________
    filter_parser = subparsers.add_parser("filter",
                                          help="Export GFF3 file to various formats")
    filter_parser.set_defaults(func=filter_annotations)
    filter_parser.add_argument("--input_gff", "-i", required=True, type=str,
                               help="URL/file path to gff file or compressed gff")
    filter_parser.add_argument("--output_file", "-o", required=True, type=str,
                               help="Output file path and name including extension")
    filter_parser.add_argument("--by", "-b", required=True, choices=["length", "type"],
                               help="Type of filtering required")
    filter_parser.add_argument("--min_len", "-n", required=False, type=int,
                               help="Minimum length required (> 0) for filtering by length")
    filter_parser.add_argument("--max_len", "-x", required=False, type=int,
                               help="Maximum length required (> 0) for filtering by length")
    filter_parser.add_argument("--annotation_type", "-t", required=False, type=str, nargs="+",
                               help="Annotation type required for filtering by type (space separated values)")
    # ___________________________________________________________________
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    # Handling inconsistent argument passes
    if args.command == "export":
        if args.export_type == 'gff' and (args.expand_attributes is True or args.drop_columns is not None):
            parser.error("Arguments error: --export_type 'gff' cannot be used with"
                         "arguments --expand_attributes or --drop_columns")
    elif args.command == "filter":
        if args.by == 'length':
            if args.min_len is None or args.max_len is None:
                parser.error("Arguments error: filter by length requires arguments --min_len and --max_len")
        elif args.by == 'type':
            if args.annotation_type is None:
                parser.error("Arguments error: filter by type requires argument --annotation_type")
        else:
            exit(1)
    else:
        pass
    # passing argument to functions
    if "func" in dir(args):
        args.func(args)
    else:
        parser.print_help()


def show_version(args):
    """
    Version
    """
    # TODO
    pass


def export_to_table(args):
    if args.export_type == "gff":
        Gff3Exporter(args.input_gff).export_to_gff(output_file=args.output_file)
    else:
        Gff3Exporter(args.input_gff).export_to_table(to=args.export_type, output_file=args.output_file,
                                                     expand_attributes=True, drop_columns=args.drop_columns)


def fetch_overlap(args):
    aof(args.input_gff_a, args.input_gff_b, args.prefix, args.output_file) \
        .fetch_overlaps(allow_different_strands=args.allow_different_strands)


def filter_annotations(args):
    if args.by == "length":
        af(args.input_gff, args.output_file).filter_by_length(args.min_len, args.max_len)
    elif args.by == "type":
        af(args.input_gff, args.output_file).filter_by_type(args.type)
    else:
        lg.error(" Unrecognized filtering option")


main()
